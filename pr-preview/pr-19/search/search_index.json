{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ECManager","text":"<p>A terminal UI to manage your AWS ElasticContainerService-Clusters</p>"},{"location":"#note","title":"Note","text":"<p>This tool is currently under development and therefore not released yet.</p>"},{"location":"evaluation/","title":"TODO","text":""},{"location":"evaluation/tui/","title":"TUI","text":"<p>This is an Evaluation for a TUI (Terminal User Interface) Library in GO.</p> <p>There are many Libarys for Buildung TUI in GO but the main ones are Tview and Bubbletea. They have the most documentation and biggest user bases so we will only evaluati these two.</p>"},{"location":"evaluation/tui/#tview","title":"Tview","text":"<p>Widget-based Imperative UI: Built around a traditional imperative programming model, tview offers predefined widgets such as tables, forms, lists, and trees, which are easy to use and integrate into an application. Efficiency: It is particularly useful for building structured and static UIs that do not require a high level of interactivity or reactivity. Its widgets are simple to implement, making it a great choice for dashboards, editors, or tools that focus on data presentation rather than interaction. Lower Learning Curve: tview\u2019s design is familiar to developers who have worked with widget-based toolkits like GTK or Qt, making it easier to learn and faster to implement. Simplicity over Flexibility: While efficient, tview is not as flexible as Bubble Tea when it comes to handling asynchronous events or creating custom UI components. It works best for UIs with less dynamic updates. Best for: Applications that require static layouts with minimal interactivity, such as terminal dashboards, text editors, or simple data browsers.</p>"},{"location":"evaluation/tui/#bubbletea","title":"Bubbletea","text":"<p>Declarative UI: Ideal for projects that require a declarative approach to building user interfaces, similar to frameworks like React or Elm. The UI is defined based on the state, which ensures that the view is always synchronized with the underlying state. Elm Architecture: Follows the Model-Update-View (MUV) pattern, offering reactive state management where the state drives the UI. This is excellent for handling asynchronous events, like background processes, network requests, or timed actions. Customization &amp; Flexibility: Well-suited for applications with highly dynamic UIs that need custom rendering or complex behavior, such as real-time dashboards, interactive CLIs, or text-based games. Learning Curve: The architecture requires understanding of functional programming principles, which might be unfamiliar to some Go developers, but it offers powerful abstractions once mastered. Best for: Projects requiring real-time interactivity, asynchronous handling, or highly customized UIs where flexibility is key.</p>"},{"location":"technical/","title":"Technical Documentation","text":"<p>This section contains technical documentation for the project.</p>"},{"location":"technical/local-dev/","title":"LocalDev","text":"<p>We are using docker-compose to run our local development. On this subsection you can find handy information about how to run the local development.</p>"},{"location":"technical/local-dev/moto/","title":"Moto","text":"<p>Moto is a library that allows you to mock out AWS services for testing purposes. It is a great way to test our code without incurring the cost of running AWS services. We use Moto as standalone server to simulate AWS locally.</p>"},{"location":"technical/local-dev/moto/#fixtures","title":"Fixtures","text":"<p>To modify the fixtures, we use a docker-compose sidecar, which add the fixtures to the moto container by using Boto3. The fixtures config can be found here.</p>"},{"location":"technical/local-dev/moto/#why-do-we-use-python-as-fixtures-loader","title":"Why do we use Python as fixtures-loader?","text":"<p>We use python for our local fixtures for 2 reasons:</p> <ul> <li>Boto3 is a greate SDK to interact with AWS</li> <li>Moto is written in python, if we need examples we get them on their repo.</li> </ul>"},{"location":"technical/mkdocs/","title":"MkDocs","text":"<p>This page contains information, like tips and tricks, about the documentation of this project.</p>"},{"location":"technical/mkdocs/css/","title":"Custom CSS","text":"<p>To add custom CSS-Files, you can add them under the <code>stylesheets</code>-Folder. After that you need to add the file to the <code>mkdocs.yml</code> under the key extra_css.</p>"},{"location":"technical/mkdocs/css/#light-filter","title":"Light-Filter","text":"<p>To create different styles for dark and light mode, you need to define your classes as followed:</p> <pre><code>/* Light Style */\n[data-md-color-scheme=\"default\"] .some-class {\n  color: black;\n}\n\n/* Dark Style */\n[data-md-color-scheme=\"slate\"] .some-class {\n  color: white;\n}\n</code></pre>"},{"location":"technical/mkdocs/makros/","title":"Makros","text":"<p>We use the Makros-Plugin from MkDocs.</p>"},{"location":"technical/mkdocs/makros/#custom-makros","title":"Custom Makros","text":"<p>All custom makros are defined in the <code>main.py</code> file.</p>"},{"location":"technical/mkdocs/makros/#decision-plugin","title":"Decision Plugin","text":"<p>To document decisions, we defined a custom makro:</p> <p>Insert Decision here"},{"location":"technical/mkdocs/makros/#notes","title":"Notes","text":""},{"location":"technical/mkdocs/makros/#inject-html-code-from-a-makro","title":"Inject HTML-Code from a makro","text":"<p>To inject HTML-Code successfully into the page, you should output the code as single line. For that you can use miniy-html</p>"}]}