{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ECManager","text":"<p>A terminal UI to manage your AWS ElasticContainerService-Clusters</p>"},{"location":"#note","title":"Note","text":"<p>This tool is currently under development and therefore not released yet.</p>"},{"location":"evaluation/","title":"TODO","text":""},{"location":"evaluation/tui-plugin/","title":"TODO","text":""},{"location":"evaluation/update-manager/","title":"Update manager","text":"<p>We want to build a secure and up-to-date software. Therefore, we have to update out code regularly. To make this process as easy as possible, we want to use an update manager.</p> <p>This eval compares 2 different update managers: <code>Renovate</code> and <code>Dependabot</code>.</p>"},{"location":"evaluation/update-manager/#requirements","title":"Requirements","text":"<p>Following requirements are important for us:</p> <ul> <li>group dependencies by type (e.g. <code>go-Dependencies</code>, <code>python-Dependencies</code>)</li> <li>easy to use</li> <li>minimal overhead to maintain</li> </ul>"},{"location":"evaluation/update-manager/#renovate","title":"Renovate","text":"<p>Renovate is tool, build by Mend and can be self-hosted or used as a service. For configuration, it uses a <code>renovate.json</code> file in the repository.</p> <p>To use Renovate, we can either host a server and deploy Renovate or install the Renovate GitHub App (for the entire Organization).</p>"},{"location":"evaluation/update-manager/#dependabot","title":"Dependabot","text":"<p>Dependabot is a tool, build by GitHub and can be used as a service. For configuration, it uses a <code>.github/dependabot.yml</code> file in the repository.</p> <p>To use Dependabot, we have to enable it in the repository settings.</p>"},{"location":"evaluation/update-manager/#comparison","title":"Comparison","text":"Feature Renovate Dependabot Hosting :red_circle: as service, connected via GitHub App (self hosted is possible, but no option for us) :green_circle: native in GitHub Configuration :green_circle: endless configuration via JSON and Environment Variables :orange: limited, but simple configuration via YAML Cost :green_circle: free :green_circle: free Security :red_circle: hosted by Mend (write access from an app) :green_circle: native in GitHub, no rights needed Grouping :green_circle: via <code>packageRules</code> :green_circle: via groups"},{"location":"evaluation/update-manager/#conclusion","title":"Conclusion","text":"<p>We have a very simple setup and don't need a lot of configuration. Therefore, Dependabot is the better choice for us, because it is native in GitHub and has no overhead to maintain. Because of the reduced features, it hat also a reduced complexity.</p> <p>We use dependabot"},{"location":"technical/","title":"Technical Documentation","text":"<p>This section contains technical documentation for the project.</p>"},{"location":"technical/local-dev/","title":"LocalDev","text":"<p>We are using docker-compose to run our local development. On this subsection you can find handy information about how to run the local development.</p>"},{"location":"technical/local-dev/moto/","title":"Moto","text":"<p>Moto is a library that allows you to mock out AWS services for testing purposes. It is a great way to test our code without incurring the cost of running AWS services. We use Moto as standalone server to simulate AWS locally.</p>"},{"location":"technical/local-dev/moto/#fixtures","title":"Fixtures","text":"<p>To modify the fixtures, we use a docker-compose sidecar, which add the fixtures to the moto container by using Boto3. The fixtures config can be found here.</p>"},{"location":"technical/local-dev/moto/#why-do-we-use-python-as-fixtures-loader","title":"Why do we use Python as fixtures-loader?","text":"<p>We use python for our local fixtures for 2 reasons:</p> <ul> <li>Boto3 is a greate SDK to interact with AWS</li> <li>Moto is written in python, if we need examples we get them on their repo.</li> </ul>"},{"location":"technical/mkdocs/","title":"MkDocs","text":"<p>This page contains information, like tips and tricks, about the documentation of this project.</p>"},{"location":"technical/mkdocs/css/","title":"Custom CSS","text":"<p>To add custom CSS-Files, you can add them under the <code>stylesheets</code>-Folder. After that you need to add the file to the <code>mkdocs.yml</code> under the key extra_css.</p>"},{"location":"technical/mkdocs/css/#light-filter","title":"Light-Filter","text":"<p>To create different styles for dark and light mode, you need to define your classes as followed:</p> <pre><code>/* Light Style */\n[data-md-color-scheme=\"default\"] .some-class {\n  color: black;\n}\n\n/* Dark Style */\n[data-md-color-scheme=\"slate\"] .some-class {\n  color: white;\n}\n</code></pre>"},{"location":"technical/mkdocs/makros/","title":"Makros","text":"<p>We use the Makros-Plugin from MkDocs.</p>"},{"location":"technical/mkdocs/makros/#custom-makros","title":"Custom Makros","text":"<p>All custom makros are defined in the <code>main.py</code> file.</p>"},{"location":"technical/mkdocs/makros/#decision-plugin","title":"Decision Plugin","text":"<p>To document decisions, we defined a custom makro:</p> <p>Insert Decision here"},{"location":"technical/mkdocs/makros/#notes","title":"Notes","text":""},{"location":"technical/mkdocs/makros/#inject-html-code-from-a-makro","title":"Inject HTML-Code from a makro","text":"<p>To inject HTML-Code successfully into the page, you should output the code as single line. For that you can use miniy-html</p>"}]}