{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ECManager","text":"<p>A terminal UI to manage your AWS ElasticContainerService-Clusters</p>"},{"location":"#note","title":"Note","text":"<p>This tool is currently under development and therefore not released yet.</p>"},{"location":"evaluation/","title":"TODO","text":""},{"location":"evaluation/tui-framework/","title":"TUI-Framework","text":"<p>We want to use a framework to build a TUI for our application. We will evaluate the most popular TUI frameworks for Go and choose the one that best fits our needs.</p>"},{"location":"evaluation/tui-framework/#frameworks","title":"Frameworks","text":"<p>There are many frameworks for building TUI in GO but the main ones are Tview and Bubbletea. They have the most documentation and biggest user bases so we will evaluate these two.</p>"},{"location":"evaluation/tui-framework/#tview","title":"Tview","text":"<p>Tview is a fast, flexible UI framework for building rich terminal applications in Golang. It offers widgets like tables, forms, and modals, making interactive console apps easy to create. Built on <code>tcell</code>, it ensures cross-platform compatibility while handling terminal operations. It works best for UIs with less dynamic updates.</p> <p>The greates project using tview is k9s</p>"},{"location":"evaluation/tui-framework/#bubbletea","title":"Bubbletea","text":"<p>Bubble Tea is a flexible, reactive framework for building terminal applications in Golang using the Model-Update-View (MVU) architecture. It allows developers to create highly interactive and dynamic UIs by handling asynchronous events and updates seamlessly. Unlike traditional imperative UI frameworks, Bubble Tea promotes a declarative style, where the UI is a function of the application's state. This makes it more flexible for building applications with complex interactions and real-time updates.</p> <p>As part of the charmbracelet suite, Bubble Tea is well-documented and actively maintained. It is used in popular projects like Superfile. Additionally, Bubble Tea has also great plugins for styling like lipgloss and glamour.</p>"},{"location":"evaluation/tui-framework/#comparison","title":"Comparison","text":"Feature Tview Bubble Tea Architecture  Imperative  Declarative Dynamic UI  Limited  Flexible Documentation Community Templates  built-in  extensions like bubbles"},{"location":"evaluation/tui-framework/#conclusion","title":"Conclusion","text":"<p>We use bubble tea with lipgloss and glamour for styling <p>With the declarative architecture, simplicity and flexibility of Bubble Tea, we can build a highly interactive and dynamic TUI for our application. Additionally, the availability of plugins like lipgloss and glamour allows us to style our UI easily.</p>"},{"location":"evaluation/update-manager/","title":"Update manager","text":"<p>We want to build a secure and up-to-date software. Therefore, we have to update out code regularly. To make this process as easy as possible, we want to use an update manager.</p> <p>This eval compares 2 different update managers: <code>Renovate</code> and <code>Dependabot</code>.</p>"},{"location":"evaluation/update-manager/#requirements","title":"Requirements","text":"<p>Following requirements are important for us:</p> <ul> <li>group dependencies by type (e.g. <code>go-Dependencies</code>, <code>python-Dependencies</code>)</li> <li>easy to use</li> <li>minimal overhead to maintain</li> </ul>"},{"location":"evaluation/update-manager/#renovate","title":"Renovate","text":"<p>Renovate is tool, build by Mend and can be self-hosted or used as a service. For configuration, it uses a <code>renovate.json</code> file in the repository.</p> <p>To use Renovate, we can either host a server and deploy Renovate or install the Renovate GitHub App (for the entire Organization).</p>"},{"location":"evaluation/update-manager/#dependabot","title":"Dependabot","text":"<p>Dependabot is a tool, build by GitHub and can be used as a service. For configuration, it uses a <code>.github/dependabot.yml</code> file in the repository.</p> <p>To use Dependabot, we have to enable it in the repository settings.</p>"},{"location":"evaluation/update-manager/#comparison","title":"Comparison","text":"Feature Renovate Dependabot Hosting  as service, connected via GitHub App (self hosted is possible, but no option for us)  native in GitHub Configuration  endless configuration via JSON and Environment Variables  limited, but simple configuration via YAML Cost  free  free Security  hosted by Mend (write access from an app)  native in GitHub, no rights needed Grouping  via <code>packageRules</code>  via groups"},{"location":"evaluation/update-manager/#conclusion","title":"Conclusion","text":"<p>We use Dependabot as our update manager <p>We have a very simple setup and don't need a lot of configuration. Therefore, Dependabot is the better choice for us. It is native integrated in GitHub and has no overhead to maintain.</p>"},{"location":"technical/","title":"Technical Documentation","text":"<p>This section contains technical documentation for the project.</p>"},{"location":"technical/bubble-tea/","title":"Bubble Tea","text":"<p>This sections contains conventions and tipps about the Bubble Tea framework.</p>"},{"location":"technical/bubble-tea/pages/","title":"Pages","text":"<p>This site contains conventions about our pages.</p>"},{"location":"technical/bubble-tea/pages/#where-to-find-and-create-pages","title":"Where to find and create pages","text":"<p>All pages are located in the <code>internal/pages</code> folder. To create a new page, create a new folder with the name of the page and add a <code>page.go</code> file.</p>"},{"location":"technical/bubble-tea/pages/#go-conventions","title":"Go Conventions","text":""},{"location":"technical/bubble-tea/pages/#file-structure","title":"File structure","text":"<p>All pages extending the <code>bubbletea.Model</code> interface. The <code>page.go</code> file should look like that:</p> <pre><code>package example\n\nimport (\n  tea \"github.com/charmbracelet/bubbletea\"\n)\n\n// page-model, implements the bubbletea\ntype page struct {\n}\n\n// Static function to create the Pagemodel\nfunc New() tea.Model {\n  return page{}\n}\n\n// Implement the tea.Model interface\n</code></pre>"},{"location":"technical/bubble-tea/pages/#use-bubbles-over-custom-components","title":"Use Bubbles over custom components","text":"<p>We want to use bubbles over custom components. This is to ensure a consistent look and feel of our application.</p>"},{"location":"technical/bubble-tea/pages/#use-lipgloss-for-styling","title":"Use lipgloss for styling","text":"<p>We use lipgloss for styling. This reduces the amount of custom CSS in our View() Methods.</p>"},{"location":"technical/bubble-tea/pages/#routing","title":"Routing","text":"<p>The routing is done by our <code>internal/route.gor</code> service. To enable routing, simply add the <code>Router</code> interface to your page model.</p> <p> Disclaimer: Currently our routing is very basic and only supports routing forward.</p>"},{"location":"technical/bubble-tea/pages/#testing","title":"Testing","text":"<p>To test your page, create a new test file in the same folder as your page. We use the teatest for our tests. We only write page-tests, which means we only test the page itself, not the components.</p> <p>All actions should be triggered by user input (type or click actions).</p>"},{"location":"technical/bubble-tea/pages/#useful-sources","title":"Useful Sources","text":"<ul> <li>Tips for Bubble Tea</li> <li>Information about Teatest</li> <li>Example Pages</li> </ul>"},{"location":"technical/local-dev/","title":"LocalDev","text":"<p>We are using docker-compose to run our local development. On this subsection you can find handy information about how to run the local development.</p>"},{"location":"technical/local-dev/moto/","title":"Moto","text":"<p>Moto is a library that allows you to mock out AWS services for testing purposes. It is a great way to test our code without incurring the cost of running AWS services. We use Moto as standalone server to simulate AWS locally.</p>"},{"location":"technical/local-dev/moto/#fixtures","title":"Fixtures","text":"<p>To modify the fixtures, we use a docker-compose sidecar, which add the fixtures to the moto container by using Boto3. The fixtures config can be found here.</p>"},{"location":"technical/local-dev/moto/#why-do-we-use-python-as-fixtures-loader","title":"Why do we use Python as fixtures-loader?","text":"<p>We use python for our local fixtures for 2 reasons:</p> <ul> <li>Boto3 is a greate SDK to interact with AWS</li> <li>Moto is written in python, if we need examples we get them on their repo.</li> </ul>"},{"location":"technical/mkdocs/","title":"MkDocs","text":"<p>This page contains information, like tips and tricks, about the documentation of this project.</p>"},{"location":"technical/mkdocs/css/","title":"Custom CSS","text":"<p>To add custom CSS-Files, you can add them under the <code>stylesheets</code>-Folder. After that you need to add the file to the <code>mkdocs.yml</code> under the key extra_css.</p>"},{"location":"technical/mkdocs/css/#light-filter","title":"Light-Filter","text":"<p>To create different styles for dark and light mode, you need to define your classes as followed:</p> <pre><code>/* Light Style */\n[data-md-color-scheme=\"default\"] .some-class {\n  color: black;\n}\n\n/* Dark Style */\n[data-md-color-scheme=\"slate\"] .some-class {\n  color: white;\n}\n</code></pre>"},{"location":"technical/mkdocs/makros/","title":"Makros","text":"<p>We use the Makros-Plugin from MkDocs.</p>"},{"location":"technical/mkdocs/makros/#custom-makros","title":"Custom Makros","text":"<p>All custom makros are defined in the <code>main.py</code> file.</p>"},{"location":"technical/mkdocs/makros/#decision-plugin","title":"Decision Plugin","text":"<p>To document decisions, we have defined a custom makro:</p> <pre><code>{{ decision(\"Insert Decision here\") }}\n</code></pre> <p>which will be rendered as:</p> <p>Insert Decision here"},{"location":"technical/mkdocs/makros/#notes","title":"Notes","text":""},{"location":"technical/mkdocs/makros/#inject-html-code-from-a-makro","title":"Inject HTML-Code from a makro","text":"<p>To inject HTML-Code successfully into the page, you should output the code as single line. For that you can use miniy-html</p>"}]}